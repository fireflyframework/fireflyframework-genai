# Copyright 2026 Firefly Software Solutions Inc
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Code generator: converts a visual graph model into executable Python code.

The generated code uses the fireflyframework-genai public API so that users
can "eject" their visual pipeline into a standalone Python script.
"""

from __future__ import annotations

from fireflyframework_genai.studio.codegen.models import GraphModel, GraphNode, NodeType

# ---------------------------------------------------------------------------
# Constants
# ---------------------------------------------------------------------------

_MODULE_DOCSTRING = '"""Pipeline generated by Firefly Studio."""'
_FUTURE_IMPORT = "from __future__ import annotations"
_AGENT_IMPORT = "from fireflyframework_genai.agents.base import FireflyAgent"
_BUILDER_IMPORT = "from fireflyframework_genai.pipeline.builder import PipelineBuilder"
_STEP_IMPORT = "from fireflyframework_genai.pipeline.steps import AgentStep"

_DEFAULT_MODEL = "openai:gpt-4o"


# ---------------------------------------------------------------------------
# Public API
# ---------------------------------------------------------------------------


def generate_python(graph: GraphModel) -> str:
    """Convert a :class:`GraphModel` into valid, human-readable Python code.

    Rules
    -----
    * If the graph has **only agent nodes and no edges**, standalone
      ``FireflyAgent`` definitions are emitted.
    * If the graph has **edges**, a ``PipelineBuilder`` pipeline is generated
      with ``.add_node()`` and ``.add_edge()`` calls.
    * The generated code is always syntactically valid Python.
    """
    agent_nodes = [n for n in graph.nodes if n.type == NodeType.AGENT]
    has_edges = len(graph.edges) > 0

    lines: list[str] = []

    # -- Module docstring & future import ------------------------------------
    lines.append(_MODULE_DOCSTRING)
    lines.append(_FUTURE_IMPORT)
    lines.append("")

    # -- Imports -------------------------------------------------------------
    if agent_nodes:
        lines.append(_AGENT_IMPORT)
    if has_edges:
        lines.append(_BUILDER_IMPORT)
        lines.append(_STEP_IMPORT)
    lines.append("")

    # -- Agent definitions ---------------------------------------------------
    for node in agent_nodes:
        lines.append(_emit_agent(node))
        lines.append("")

    # -- Pipeline builder (only when edges exist) ----------------------------
    if has_edges:
        lines.append(_emit_pipeline(agent_nodes, graph))

    return "\n".join(lines)


# ---------------------------------------------------------------------------
# Internal helpers
# ---------------------------------------------------------------------------


def _emit_agent(node: GraphNode) -> str:
    """Emit a ``FireflyAgent(...)`` definition for a single node."""
    name = node.id
    model = node.data.get("model", _DEFAULT_MODEL) or _DEFAULT_MODEL
    instructions = node.data.get("instructions", "")

    instr_literal = _format_string_literal(instructions)

    return f'{name} = FireflyAgent(\n    name="{name}",\n    model="{model}",\n    instructions={instr_literal},\n)'


def _emit_pipeline(agent_nodes: list[GraphNode], graph: GraphModel) -> str:
    """Emit a ``PipelineBuilder`` block that wires all nodes and edges."""
    parts: list[str] = []
    parts.append("pipeline = (")
    parts.append('    PipelineBuilder("pipeline")')

    for node in agent_nodes:
        parts.append(f'    .add_node("{node.id}", AgentStep({node.id}))')

    for edge in graph.edges:
        parts.append(f'    .add_edge("{edge.source}", "{edge.target}")')

    parts.append("    .build()")
    parts.append(")")
    return "\n".join(parts)


def _format_string_literal(value: str) -> str:
    """Return a Python string literal for *value*.

    * Simple single-line strings without problematic characters use ``"..."``.
    * Multi-line strings (containing ``\\n``) use triple-quoted strings so the
      generated code is readable.
    * Strings containing triple-double-quotes fall back to triple-single-quotes
      (and vice-versa) to guarantee valid syntax.
    * Backslashes are always properly escaped.
    """
    if not value:
        return '""'

    has_newline = "\n" in value

    if not has_newline:
        # Single-line: use repr() for robust escaping, then normalise to
        # double-quote style for consistency with the template spec.
        return _repr_double_quoted(value)

    # Multi-line: use triple-quoted strings for readability.
    # First escape backslashes so they survive the round-trip.
    escaped = value.replace("\\", "\\\\")

    has_triple_double = '"""' in escaped
    has_triple_single = "'''" in escaped

    if not has_triple_double:
        # Escape any lone trailing backslash-before-quote and stray quotes
        inner = escaped.replace('"', '\\"') if escaped.endswith('"') else escaped
        # If the escaped value itself doesn't contain """, we're safe.
        if '"""' not in inner:
            return f'"""{inner}"""'

    if not has_triple_single:
        inner = escaped.replace("'", "\\'") if escaped.endswith("'") else escaped
        if "'''" not in inner:
            return f"'''{inner}'''"

    # Fallback: escape triple-double-quotes inside triple-double-quoted string
    inner = escaped.replace('"""', '\\"\\"\\"')
    return f'"""{inner}"""'


def _repr_double_quoted(value: str) -> str:
    """Return a double-quoted Python string literal for *value*.

    Uses :func:`repr` for robust escaping, then normalises the output to
    use double quotes so the generated code matches the project convention.
    """
    r = repr(value)

    # repr() returns either 'x' or "x" depending on content.
    if r.startswith("'") and r.endswith("'"):
        # The interior was escaped for single-quote context.  Convert:
        #   'She said "hi"'  ->  "She said \"hi\""
        inner = r[1:-1]
        # Un-escape single quotes that repr escaped
        inner = inner.replace("\\'", "'")
        # Escape double quotes for the new context
        inner = inner.replace('"', '\\"')
        return f'"{inner}"'

    # Already double-quoted (contains single quotes)
    return r
